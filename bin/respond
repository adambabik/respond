#!/usr/bin/env node

var program = require('commander'),
	server = require('../src/server'),
	watcher = require('../src/watcher'),
	debug = require('../src/debug'),
	pkg = require('../package.json');

function list(val) {
	return val.split(' ');
}

function actions(val) {
	return val.split(' ').reduce(function (prev, item) {
		var tuple = item.split('=');
		prev[tuple[0]] = tuple[1];
		return prev;
	}, {});
}

var options = {
	port: 3000,
	watch: [],
	action: {
		'js': 'refresh',
		'css': 'refreshCSS'
	},
	exclude: []
};

program
	.version(pkg.version)
	.usage('[options]')
	.option('-p, --port <n>', 'set up server port', parseInt)
	.option('-w, --watch <files>', 'files and directories to watch', list)
	.option('-a, --actions <actions>', 'actions to execute after file change, e.g. js=refresh means that after change is JavaScript file, refresh command is sent', actions)
	.option('-e, --exclude <files>', 'excludes files from being observed', list)
	.option('-d, --debug', 'turns on debug logs to STDOUT', Boolean)
	.parse(process.argv);

if (program.debug) {
	debug.debug(program.debug);
}

if (program.port) {
	options.port = program.port;
	debug.debug() && console.log('Port: %d', program.port);
}

if (program.watch) {
	options.watch = program.watch;
	debug.debug() && console.log('Watching files:', program.watch);
}

if (program.actions) {
	options.action = program.actions;
	debug.debug() && console.log('Actions:', program.actions);
}

if (program.exclude) {
	options.exclude = program.exclude;
	debug.debug() && console.log('Exclude:', program.exclude);	
}

// Server

server.listen(options.port);

// Watch

if (program.watch && program.watch.length > 0) {
	watcher.watch(options.watch, options.exclude, options.action);
}

// CLI

var isWaiting = false,
	commandDate = -1,
	interval = -1;

function showHelp() {
	console.log();
	console.log('  Special commands:');
	console.log();
	console.log('    :quit                 close application');
	console.log('    :help                 show help');
	console.log();
	console.log('  Regular commands:');
	console.log();
	console.log('    eval <command>        evaluate command on active web pages and return replay');
	console.log('    refresh               reload active web pages');
	console.log('    refreshCSS [<files>]  reload only selected CSS files');
	console.log();
}

function asyncPrompt() {
	process.nextTick(function () {
		prompt();
	});
}

function cancelWaiting() {
	clearInterval(interval);
	isWaiting = false;
}

// Subscribe on messages from clients

server.subscribe(function (message) {
	debug.debug() && console.log('>>> [ received ]', message);
	cancelWaiting();
	asyncPrompt();
});

function prompt(first) {
	if (first) {
		console.log('\nTo get some help type :help');
	}

	program.prompt('respond> ', function (command) {
		var parts = list(command),
			cmd = parts.shift();

		switch (cmd) {
		case ':quit':
			server.close(function () {
				process.exit();
			});
			break;

		case ':help':
			showHelp();
			break;

		default:
			server.command(cmd, { data: parts.join(' ') });
			break;
		}

		if (isWaiting) {
			// @TODO replace with setTimeout
			interval = setInterval(function () {
				if (!isWaiting || Date.now() - commandDate > 5 * 1000) {
					process.stdout.write(' timeout\n');
					cancelWaiting();
				} else {
					process.stdout.write('.');
				}
			}, 1000);
		} else {
			asyncPrompt();
		}
	});	
}

// Start!

prompt(true);
